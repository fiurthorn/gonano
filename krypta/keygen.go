package krypta

import (
	"bytes"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"filippo.io/age"
)

func Keygen(IdentitiesFilePath, RecipientsFilePath string) {
	if _, err := os.Stat(IdentitiesFilePath); !errors.Is(err, os.ErrNotExist) {
		log.Fatalf("IdentityFile exists: %s", IdentitiesFilePath)
	}

	k, err := age.GenerateX25519Identity()
	if err != nil {
		log.Fatalf("internal error: %v", err)
	}

	sb := strings.Builder{}
	sb.WriteString("# created: ")
	sb.WriteString(time.Now().Format(time.RFC3339))
	sb.WriteRune('\n')
	sb.WriteString("# public key: ")
	sb.WriteString(k.Recipient().String())
	sb.WriteRune('\n')
	sb.WriteString(k.String())
	sb.WriteRune('\n')

	passphrase, err := passphrasePromptForEncryption()
	if err != nil {
		log.Fatalf("Passphrase: %v", err)
	}
	writeEncryptedSecret(IdentitiesFilePath, passphrase, bytes.NewBufferString(sb.String()))

	flags := os.O_WRONLY | os.O_EXCL
	if _, err := os.Stat(RecipientsFilePath); errors.Is(err, os.ErrNotExist) {
		flags |= os.O_CREATE
	} else {
		flags |= os.O_APPEND
	}

	recipientsFile, err := os.OpenFile(RecipientsFilePath, flags, 0600)
	if err != nil {
		log.Fatal(err)
	}
	defer recipientsFile.Close()

	fmt.Fprintf(recipientsFile, "# %s\n", os.Getenv("USERNAME"))
	fmt.Fprintf(recipientsFile, "%s\n", k.Recipient())
}

func passphrasePromptForEncryption() (string, error) {
	pass, err := readSecret("Enter passphrase (leave empty to autogenerate a secure one):")
	if err != nil {
		return "", fmt.Errorf("could not read passphrase: %v", err)
	}
	p := string(pass)
	if p == "" {
		var words []string
		for i := 0; i < 10; i++ {
			words = append(words, randomWord())
		}
		p = strings.Join(words, "-")
		err := printfToTerminal("using autogenerated passphrase %q", p)
		if err != nil {
			return "", fmt.Errorf("could not print passphrase: %v", err)
		}
	} else {
		confirm, err := readSecret("Confirm passphrase:")
		if err != nil {
			return "", fmt.Errorf("could not read passphrase: %v", err)
		}
		if string(confirm) != p {
			return "", fmt.Errorf("passphrases didn't match")
		}
	}
	return p, nil
}

func RecipientsFile() string {
	var home string
	var err error

	if home, err = os.UserHomeDir(); err != nil {
		log.Fatalf("UserHomeDir: %v", err)
	}

	return filepath.Join(home, "recipients.key")
}

func IdentitiesFile() string {
	var home string
	var err error

	if home, err = os.UserHomeDir(); err != nil {
		log.Fatalf("UserHomeDir: %v", err)
	}

	return filepath.Join(home, "identity.key")
}
